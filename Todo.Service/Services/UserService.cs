using MapsterMapper;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using Todo.Infrastructure.Interface;
using Todo.Service.Interface;
using Todo.Service.Models.Configuration;
using Todo.Service.Models.DTOs;
using RepositoriesModels = Todo.Infrastructure.Models.Entities;

namespace Todo.Service.Services;

public class UserService : IUserService
{
    private JwtConfig _jwtConfig;
    private readonly IUserRepository _userRepository;
    private readonly IMapper _iMapper;
    public UserService(JwtConfig jwtConfig, IUserRepository userRepository, IMapper iMapper)
    {
        _jwtConfig = jwtConfig;
        _userRepository = userRepository;
        _iMapper = iMapper;
    }

    public async Task<bool> Create(UserDto data)
    {
        data.Password = GenerateSaltedHash(data.Password!);
        return await _userRepository.Create(_iMapper.Map<RepositoriesModels.User>(data));
    }

    public async Task<string?> Login(UserDto user)
    {
        user.Password = GenerateSaltedHash(user.Password);
        if (await _userRepository.Login(_iMapper.Map<RepositoriesModels.User>(user)))
            return GenerateToken(user);
        return null;
    }

    #region Private method
    private string? GenerateToken(UserDto user)
    {
        var issuer = _jwtConfig.Issuer;
        var audience = _jwtConfig.Audience;
        var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtConfig.Key!));
        var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

        var jwtTokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_jwtConfig.Key);

        // we define our token descriptor
        // We need to utilise claims which are properties in our token which gives information about the token
        // which belong to the specific user who it belongs to
        // so it could contain their id, name, email the good part is that these information
        // are generated by our server and identity framework which is valid and trusted
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim(JwtRegisteredClaimNames.Sub, user.UserName),
                            new Claim(JwtRegisteredClaimNames.Email, user.UserName),
                            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
                        }),
            //in real life, we set a short period of expire date,
            //then add in refresh token to regenerate every x amount of time to prevent user leak out the user token
            Expires = DateTime.UtcNow.AddHours(1),
            Audience = audience,
            Issuer = issuer,
            //  adding the encryption algorithm information which will be used to decrypt our token
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key),
                SecurityAlgorithms.HmacSha512Signature)
        };

        var token = jwtTokenHandler.CreateToken(tokenDescriptor);
        return jwtTokenHandler.WriteToken(token);
    }

    private static string GenerateSaltedHash(string password)
    {
        byte[] salt = Encoding.ASCII.GetBytes("zxcjoeriudungusnpunepurn4u283983h4");
        byte[] plainText = Encoding.ASCII.GetBytes(password);
        HashAlgorithm algorithm = new SHA256Managed();

        byte[] plainTextWithSaltBytes =
            new byte[plainText.Length + salt.Length];

        for (int i = 0; i < plainText.Length; i++)
        {
            plainTextWithSaltBytes[i] = plainText[i];
        }
        for (int i = 0; i < salt.Length; i++)
        {
            plainTextWithSaltBytes[plainText.Length + i] = salt[i];
        }

        byte[] passwordByte = algorithm.ComputeHash(plainTextWithSaltBytes);
        return Encoding.UTF8.GetString(passwordByte, 0, passwordByte.Length);
    }
    private static bool CompareByteArrays(string password1, string password2)
    {
        byte[] array1 = Encoding.UTF8.GetBytes(password1);
        byte[] array2 = Encoding.UTF8.GetBytes(password2);
        if (array1.Length != array2.Length)
        {
            return false;
        }

        for (int i = 0; i < array1.Length; i++)
        {
            if (array1[i] != array2[i])
            {
                return false;
            }
        }

        return true;
    } 
    #endregion
}